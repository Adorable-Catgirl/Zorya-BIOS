local boot = function()
	local cproxy,clist,cinvoke,sformat,srep,schar=component.proxy,component.list,component.invoke,string.format,string.rep,string.char
	local skey = schar(0x30,0x56,0x30,0x10,0x06,0x07,0x2a,0x86,0x48,0xce,0x3d,0x02,0x01,0x06,0x05,0x2b,0x81,0x04,0x00,0x0a,0x03,0x42,0x00,0x04,0x3f,0xd9,0x45,0x71,0x17,0x45,0xea,0x71,0xcf,0x38,0xfe,0x34,0xcf,0xd8,0x35,0xbc,0x19,0x60,0x84,0x24,0x67,0xd0,0x39,0x79,0x13,0x4c,0x69,0x57,0xb1,0xa0,0x5c,0xa2,0x5b,0x6f,0xcb,0xdb,0x49,0xae,0xd2,0xbd,0xcd,0xa0,0xb5,0x86,0xa0,0xd1,0x88,0xbd,0x9a,0xf2,0x67,0xe9,0xc8,0xd5,0xac,0xb5,0x4f,0x90,0x11,0x4f,0x75,0xaf,0x03,0x57)
	_BIOS="Zorya"
	_ZVER="2.0"
	zorya = {}
	local null = schar(0)
	local _x = "%.2x"
	local function b2a(data)
		data = data or null:rep(16)
		data = null:rep(16-#data) .. data
		return sformat(sformat("%s-%s%s",srep(_x, 4),srep(_x.._x.."-",3),srep(_x,6)),string.byte(data, 1,#data))
	end
	local function a2b(addr)
		addr=addr:gsub("%-", "")
		local baddr = ""
		for i=1, #addr, 2 do
			baddr = baddr .. schar(tonumber(addr:sub(i, i+1), 16))
		end
		return baddr
	end
	function loadfile(fs, file)
		local handle = assert(cinvoke(fs, "open", file))
		local buffer = ""
		repeat
			local data = cinvoke(fs, "read", handle, math.huge)
			buffer = buffer .. (data or "")
		until not data
		cinvoke(fs, "close", handle)
		return load(buffer, "=hd("..fs:sub(1,3).."...)/"..file)
	end
	--Init GPU
	local gpu = cproxy(clist("gpu")())
	local screen = clist("screen")()
	gpu.bind(screen)
	local w, h = gpu.getViewport()
	gpu.set(1, 1, "Zorya BIOS ".._ZVER.." Bootstrap")
	local eepromaddr = clist("eeprom")()
	local data, prox = clist("data")()
	--Load config data
	local rcd = cinvoke(eepromaddr, "getData")
	local function eepromcfg(e)
		gpu.set(1, h-1, "EEPROM Config corrupt.")
		gpu.set(1, h, "Strike any key to load defaults.")
		while true do
			if (computer.pullSignal() == "key_down") then
				break
			end
		end
		while true do
			if (computer.pullSignal() == "key_up") then
				break
			end
		end
		local zfs
		for fs in clist("filesystem") do
			if cinvoke(fs, "isDirectory", "zorya-modules") then
				zfs = fs
				break
			end
		end
		if not zfs then
			gpu.fill(1, 1, w, h, " ")
			gpu.set(1, h-1, "Cannot find Zorya Modules.")
			gpu.set(1, h, "Strike any key to boot in recovery mode.")
			while true do
				if (computer.pullSignal() == "key_down") then
					break
				end
			end
			while true do
				if (computer.pullSignal() == "key_up") then
					break
				end
			end
			for fs in clist("filesystem") do
				if (cinvoke(fs, "exists", "init.lua")) then
					computer.getBootAddress = function() return fs end
					computer.setBootAddress = function()end
					zorya.getMode = function()return "recovery"end
					assert(loadfile(cproxy(fs), "init.lua"))()
					error("OS should not return in recovery mode!")
				end
			end
		end
		local dat = schar(2)..null:rep(17).."F"
		dat = dat .. null:rep(192-#dat)..a2b(zfs)..null:rep(16)
		dat = dat .. assert(cinvoke(data, "sha256", dat), "error?")
		cinvoke(e, "setData", dat)
	end
	if (rcd == "") then
		eepromcfg(eepromaddr)
	end
	local zcd = rcd:sub(193)
	local hash = zcd:sub(33)
	if (data) then
		if (cinvoke(data, "sha256", rcd:sub(1, 224)) ~= hash) then
			eepromcfg(eepromaddr)
		end
	end
	local cfgdata = {
		oefi = {
			ver = rcd:byte(1),
			lastaddr = b2a(rcd:sub(2, 17)),
			name = rcd:sub(19, 19+rcd:byte(18)),
			rtn = rcd:sub(20+rcd:byte(18)) == "T"
		},
		moddrv = b2a(zcd:sub(1, 16))
	}
	if (data) then
		prox = cproxy(data)
		if (prox.ecdsa) then
			_BIOSSIGN = true
			--Enables BIOS signing.
			local oldprox = cproxy
			local oldinv = cinvoke
			local function set() return nil, "BIOS signing enforced." end
			local function setsign(data, sig)
				local key = prox.deserializeKey(skey, "ec-public")
				if (prox.ecdsa(data, key, sig)) then
					if (load(data)) then
							oldinv(eepromaddr, "set", data)
							return true
						end
						return false, "BIOS has syntax error."
				end
				return false, "Bad signature or public key."
			end
			function component.proxy(addr)
				if (addr == eepromaddr) then
					local rtn = oldprox(addr)
					rtn.set = set
					rtn.setSign = setsign
					return rtn
				else
					return oldprox(addr)
				end
			end
			function component.invoke(addr, meth, ...)
				if (addr == eepromaddr) then
					if (meth == "set") then
						return set()
					elseif (meth == "setSign") then
						return setsign(...)
					end
				else
					return oldinv(addr, meth, ...)
				end
			end
		end
	end

	--Also, we need to load all our components here.
	local zy = cproxy(cfgdata.moddrv)
	local inet = clist("internet")() --We don't *need* internet.
	inet = inet and cproxy(inet)

	--Some GPU setup code...
	local w, h = gpu.getResolution()
	gpu.setResolution(w, h)
	gpu.setBackground(0)
	gpu.setForeground(0xFFFFFF)
	gpu.fill(1, 1, w, h, " ")

	--A few things for nice printing of things...
	local cls = function()gpu.fill(1,1,w,h," ");y=1;end
	local y = 1
	local function status(msg)
			if gpu and screen then
				gpu.set(1, y, msg)
					if y == h then
						gpu.copy(1, 2, w, h-1, 0, -1)
						gpu.fill(1, h, w, 1, " ")
					else
							y = y + 1
					end
			end
	end
	cls()
	function zorya.getMode()return"zorya"end
	local envs = {}

	envs.hand = {}
	envs.boot = {}
	envs.args = {}
	envs.scan = {}
	envs.set = {}
	envs.net = inet
	envs.gpu = gpu
	envs.cls = cls
	envs.w = w
	envs.h = h
	envs.cls = cls
	envs.status = status
	envs.loadfile = loadfile
	envs.device = zy.address
	local tbl = zy.list("zorya-modules")
	table.sort(tbl)
	for _, file in ipairs(tbl) do
		status("Loading zorya-modules/"..file)
		if (file ~= "boot.lua") then
			local func, err = loadfile(zy.address, "zorya-modules/"..file)
			if not func then error(err) else func(envs)end
		end
	end
end
local err = function(e)
	error(e.."\n"..debug.traceback())
end
assert(xpcall(boot, err))